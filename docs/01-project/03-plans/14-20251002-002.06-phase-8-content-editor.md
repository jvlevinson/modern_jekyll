# Phase 8: Content Editor - Future Roadmap
**Document ID**: 14-20251002-002.06
**Created**: October 2, 2025
**Status**: 📋 Planning - Not Yet Started
**Estimated Duration**: 4-5 weeks (60-80 hours)
**Priority**: 🟡 Medium - Enhanced content management
**Dependencies**: Phase 7 complete (Theme Editor)
**Type**: Future enhancement roadmap

---

## Overview

Phase 8 extends the Onboard Dashboard with **content editing capabilities**, allowing users to modify site content (hero text, services, portfolio items, etc.) through a visual interface without editing YAML files.

---

## Objectives

### Primary Goals

1. **Edit Hero Section**
   - Update heading, description, button text
   - Change background image
   - Toggle section visibility

2. **Manage Services**
   - Add/remove/reorder services
   - Edit titles, descriptions, icons
   - Preview changes live

3. **Manage Portfolio Items**
   - Add/remove portfolio entries
   - Edit titles, categories, descriptions
   - Upload/replace images
   - Reorder items

4. **Edit Contact Section**
   - Update heading, description
   - Modify email/phone
   - Update social links

### Secondary Goals

5. **Content Validation**
   - Required fields enforcement
   - Character limits
   - Image size/format validation

6. **Live Preview**
   - See changes in real-time
   - Preview before save

7. **Undo/Redo**
   - Multi-level undo
   - Restore previous versions

---

## Architecture Overview

### Content Management System (CMS)

**Approach**: Lightweight, file-based CMS integrated into dashboard

```
Components:
├── Form System (Reusable)
│   ├── TextInput
│   ├── TextArea
│   ├── ImageUpload
│   ├── IconPicker
│   └── SortableList
├── Content Managers
│   ├── HeroManager
│   ├── ServicesManager
│   ├── PortfolioManager
│   └── ContactManager
├── Validation System
│   ├── Schema validation (Zod/TypeScript)
│   ├── File validation
│   └── Content validation
└── History System
    ├── Undo/Redo stack
    └── Auto-save drafts
```

---

## Detailed Features

### Feature 1: Hero Section Editor

**User Story**: As a developer, I want to edit the hero section without touching `_config.yml`

**UI Design**:
```
┌─────────────────────────────────────────┐
│ Hero Section Editor                     │
├─────────────────────────────────────────┤
│                                         │
│ Heading:                                │
│ ┌─────────────────────────────────────┐ │
│ │ IT Leadership Portfolio             │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ Description:                            │
│ ┌─────────────────────────────────────┐ │
│ │ Skilled IT leader with 12+ years    │ │
│ │ of experience...                    │ │
│ │                                     │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ Button Text:                            │
│ ┌─────────────────────────────────────┐ │
│ │ View My Work                        │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ Button Link:                            │
│ ┌─────────────────────────────────────┐ │
│ │ #portfolio                          │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ Background Image:                       │
│ ┌─────────────┐                         │
│ │   [Image]   │  [Change Image]         │
│ │  Preview    │  [Remove Image]         │
│ └─────────────┘                         │
│                                         │
│ [Save Changes] [Reset] [Cancel]         │
└─────────────────────────────────────────┘
```

**Implementation**:
```typescript
// onboard/src/modules/hero-manager.ts

export interface HeroContent {
  heading: string;
  description: string;
  button_text: string;
  button_link: string;
  background_image: string;
}

export function createHeroManager(containerId: string) {
  let currentContent: HeroContent;

  function render() {
    // Render form UI
  }

  function handleSave() {
    // Validate
    // Update _config.yml via API
    // Trigger rebuild
  }

  return { render, save, reset };
}
```

---

### Feature 2: Services Manager

**User Story**: As a developer, I want to add/edit/remove services visually

**UI Design**:
```
┌─────────────────────────────────────────┐
│ Services Manager              [+ Add]   │
├─────────────────────────────────────────┤
│                                         │
│ Service 1:                              │
│ ┌─────────────────────────────────────┐ │
│ │ Icon: [fa-diamond ▼]                │ │
│ │ Title: IT Strategy & Leadership     │ │
│ │ Description:                        │ │
│ │ ┌─────────────────────────────────┐ │ │
│ │ │ Over a decade of experience...  │ │ │
│ │ └─────────────────────────────────┘ │ │
│ │                                     │ │
│ │ [↑ Move Up] [↓ Move Down] [✕ Remove]│ │
│ └─────────────────────────────────────┘ │
│                                         │
│ Service 2:                              │
│ ┌─────────────────────────────────────┐ │
│ │ ... (similar)                       │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ [Save All Changes] [Reset]              │
└─────────────────────────────────────────┘
```

**Features**:
- ✅ Drag-and-drop reordering
- ✅ Icon picker (Font Awesome browser)
- ✅ Live character count
- ✅ Duplicate service
- ✅ Delete with confirmation

**Implementation**:
```typescript
// onboard/src/modules/services-manager.ts

export interface Service {
  id: string;  // Auto-generated UUID
  icon: string;  // Font Awesome class
  title: string;
  description: string;
  order: number;  // For sorting
}

export function createServicesManager(containerId: string) {
  let services: Service[] = [];

  function addService() {
    const newService: Service = {
      id: crypto.randomUUID(),
      icon: 'fa-diamond',
      title: '',
      description: '',
      order: services.length
    };
    services.push(newService);
    render();
  }

  function removeService(id: string) {
    if (confirm('Delete this service?')) {
      services = services.filter(s => s.id !== id);
      render();
    }
  }

  function moveService(id: string, direction: 'up' | 'down') {
    // Swap order values
    // Re-render
  }

  return { render, addService, removeService, moveService, save };
}
```

---

### Feature 3: Portfolio Manager

**User Story**: As a developer, I want to manage portfolio items with image uploads

**UI Design**:
```
┌─────────────────────────────────────────┐
│ Portfolio Manager         [+ Add Item]  │
├─────────────────────────────────────────┤
│                                         │
│ ┌─────────────────────────────────────┐ │
│ │ Portfolio Item 1              [↕️][✕]│ │
│ ├─────────────────────────────────────┤ │
│ │ ┌─────┐  Name:                      │ │
│ │ │Image│  SCI - Senior IT Manager    │ │
│ │ │     │                             │ │
│ │ └─────┘  Category: Enterprise IT    │ │
│ │          [Change]                   │ │
│ │                                     │ │
│ │  Description (flip card):           │ │
│ │  ┌───────────────────────────────┐  │ │
│ │  │ Led enterprise IT strategy... │  │ │
│ │  └───────────────────────────────┘  │ │
│ │                                     │ │
│ │  Link: #                            │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ [Save All] [Preview] [Reset]            │
└─────────────────────────────────────────┘
```

**Features**:
- ✅ Image upload with preview
- ✅ Image cropping/resizing
- ✅ Auto-optimization (WebP conversion)
- ✅ Drag-and-drop reordering
- ✅ Category management

**Implementation**:
```typescript
// onboard/src/modules/portfolio-manager.ts

export interface PortfolioItem {
  id: string;
  image: string;  // Path to image
  category: string;
  name: string;
  link: string;
  flip_description: string;
  order: number;
}

export interface ImageUploadResult {
  filename: string;
  path: string;
  size: number;
  optimized: boolean;
}

export function createPortfolioManager(containerId: string) {
  async function uploadImage(file: File): Promise<ImageUploadResult> {
    // 1. Validate file (size, format)
    // 2. Upload to server via API
    // 3. Server optimizes (WebP, resize)
    // 4. Return path
  }

  function addItem() {
    const newItem: PortfolioItem = {
      id: crypto.randomUUID(),
      image: '',
      category: '',
      name: '',
      link: '#',
      flip_description: '',
      order: items.length
    };
    items.push(newItem);
    render();
  }

  return { render, addItem, uploadImage, save };
}
```

---

## Technical Implementation

### API Endpoints (Jekyll Plugin)

**New endpoints needed**:

```ruby
# _plugins/onboard_content_api.rb

module Onboard
  class ContentAPI < APIMiddleware
    def call(env)
      case env['REQUEST_PATH']
      when '/onboard/api/content/hero'
        handle_hero(env)
      when '/onboard/api/content/services'
        handle_services(env)
      when '/onboard/api/content/portfolio'
        handle_portfolio(env)
      when '/onboard/api/upload/image'
        handle_image_upload(env)
      else
        super
      end
    end

    private

    # GET /onboard/api/content/hero
    def handle_hero(env)
      config = load_config
      json_response(200, config['hero'])
    end

    # POST /onboard/api/content/hero (update)
    def handle_hero_update(env)
      data = parse_request_body(env)
      update_config_section('hero', data)
      json_response(200, { success: true })
    end

    # POST /onboard/api/upload/image
    def handle_image_upload(env)
      # 1. Parse multipart/form-data
      # 2. Validate image (size, format)
      # 3. Save to img/ directory
      # 4. Optimize (ImageMagick, cwebp)
      # 5. Return path
    end
  end
end
```

---

### Form Component System

**Reusable form components** (TypeScript):

```typescript
// onboard/src/components/form/TextInput.ts

export interface TextInputProps {
  label: string;
  value: string;
  placeholder?: string;
  maxLength?: number;
  required?: boolean;
  onChange: (value: string) => void;
}

export function createTextInput(props: TextInputProps) {
  const container = document.createElement('div');
  container.className = 'form-group';

  const render = () => {
    const charCount = props.maxLength
      ? `<span class="form-group__count">${props.value.length}/${props.maxLength}</span>`
      : '';

    container.innerHTML = `
      <label class="form-group__label">
        ${props.label}
        ${props.required ? '<span class="required">*</span>' : ''}
        ${charCount}
      </label>
      <input
        type="text"
        class="form-group__input"
        value="${props.value}"
        placeholder="${props.placeholder || ''}"
        maxlength="${props.maxLength || ''}"
        ${props.required ? 'required' : ''}
      />
    `;

    const input = container.querySelector('input');
    input?.addEventListener('input', (e) => {
      props.onChange((e.target as HTMLInputElement).value);
      render(); // Re-render for character count
    });
  };

  render();
  return container;
}
```

**Similar components**:
- TextArea (with auto-resize)
- ImageUpload (with drag-and-drop)
- IconPicker (Font Awesome browser)
- SortableList (drag-and-drop reordering)
- Select/Dropdown

---

### Validation System

**Schema-based validation** (Zod or TypeScript):

```typescript
// onboard/src/validation/hero-schema.ts

import { z } from 'zod';

export const HeroSchema = z.object({
  heading: z.string()
    .min(5, 'Heading must be at least 5 characters')
    .max(100, 'Heading must be less than 100 characters'),

  description: z.string()
    .min(20, 'Description must be at least 20 characters')
    .max(500, 'Description must be less than 500 characters'),

  button_text: z.string()
    .min(3, 'Button text must be at least 3 characters')
    .max(30, 'Button text must be less than 30 characters'),

  button_link: z.string()
    .regex(/^(#|https?:\/\/)/, 'Must be a # anchor or http(s) URL'),

  background_image: z.string()
    .regex(/\.(jpg|jpeg|png|webp)$/, 'Must be a valid image file')
});

export type HeroContent = z.infer<typeof HeroSchema>;

// Usage
function validateHero(data: unknown): HeroContent {
  return HeroSchema.parse(data);  // Throws if invalid
}
```

---

### Undo/Redo System

**Implementation**:

```typescript
// onboard/src/utils/history.ts

export class History<T> {
  private states: T[] = [];
  private currentIndex: number = -1;

  push(state: T) {
    // Remove any states after current index
    this.states = this.states.slice(0, this.currentIndex + 1);

    // Add new state
    this.states.push(state);
    this.currentIndex++;

    // Limit history size
    if (this.states.length > 50) {
      this.states.shift();
      this.currentIndex--;
    }
  }

  undo(): T | null {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.states[this.currentIndex];
    }
    return null;
  }

  redo(): T | null {
    if (this.currentIndex < this.states.length - 1) {
      this.currentIndex++;
      return this.states[this.currentIndex];
    }
    return null;
  }

  canUndo(): boolean {
    return this.currentIndex > 0;
  }

  canRedo(): boolean {
    return this.currentIndex < this.states.length - 1;
  }
}

// Usage in ContentManager
const history = new History<ContentState>();

function updateContent(newContent: ContentState) {
  history.push(newContent);
  // ... update UI
}

function handleUndo() {
  const previousState = history.undo();
  if (previousState) {
    applyState(previousState);
  }
}
```

---

## Implementation Timeline

### Week 1-2: Form System & Hero Editor (20 hours)

**Tasks**:
- [ ] Build reusable form components
- [ ] Implement validation system
- [ ] Create Hero editor UI
- [ ] Wire to API
- [ ] Test hero editing workflow

### Week 3: Services Manager (16 hours)

**Tasks**:
- [ ] Build services editor UI
- [ ] Implement drag-and-drop
- [ ] Add icon picker
- [ ] API integration
- [ ] Test services CRUD

### Week 4: Portfolio Manager (20 hours)

**Tasks**:
- [ ] Build portfolio editor UI
- [ ] Implement image upload
- [ ] Image optimization pipeline
- [ ] Drag-and-drop reordering
- [ ] API integration

### Week 5: Polish & Testing (16 hours)

**Tasks**:
- [ ] Undo/Redo system
- [ ] Error handling
- [ ] Accessibility audit
- [ ] E2E tests
- [ ] Documentation

**Total**: 72 hours (~5 weeks)

---

## Success Criteria

### Functional
- [ ] All content sections editable via UI
- [ ] Image upload working (with optimization)
- [ ] Validation prevents invalid content
- [ ] Undo/Redo functional
- [ ] Live preview updates
- [ ] Save persists changes to `_config.yml`

### Technical
- [ ] TypeScript compiles with no errors
- [ ] Test coverage ≥ 85%
- [ ] Bundle size < 200KB (content + theme editors combined)
- [ ] Lighthouse score maintained (≥ 95)

### UX
- [ ] Form UI intuitive
- [ ] Validation messages helpful
- [ ] Character counts visible
- [ ] Image uploads provide feedback
- [ ] Undo/Redo keyboard shortcuts (Ctrl+Z, Ctrl+Shift+Z)

---

## Future Enhancements (Post-Phase 8)

### Content Templates
- Pre-built content templates
- Import/export content
- Content library

### Advanced Editing
- Rich text editor (Markdown)
- Image cropping/filters
- Bulk operations

### Collaboration
- Change history log
- Review/approve workflow
- Multi-user editing (future)

---

**Document Status**: 📋 Planning Only
**Implementation**: Not Started
**Dependencies**: Phase 7 must be complete
**Next Phase**: Phase 9 (Advanced Features)
