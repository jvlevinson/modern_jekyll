# Phase 7: Onboard Dashboard Theme Editor - Implementation Plan
**Document ID**: 09-20251002-002.01
**Created**: October 2, 2025
**Phase Duration**: Week 7-9 (16-20 hours)
**Priority**: ðŸŸ¢ Medium - Enhanced developer experience
**Dependencies**: Phase 6 complete (Read-only dashboard, performance optimization)
**Parent Plan**: 01-20251001-001.00-architectural-improvements.md

---

## Overview

Upgrade the Onboard Dashboard from read-only viewer to **interactive theme editor**, allowing developers to modify theme configuration through a visual UI, save changes to `_config.yml`, and see live preview updates.

---

## Phase Goals

- âœ… Build theme editor UI with color pickers
- âœ… Implement config save functionality (write to `_config.yml`)
- âœ… Add live preview updates (CSS variable injection)
- âœ… Create auto-rebuild system
- âœ… Maintain BEM architecture and design token integration

---

## Architecture Strategy

### Modern, Atomic, Tokenized Approach

**Backend**:
- Ruby Jekyll plugin for file operations
- REST API endpoints (localhost only)
- Atomic file writes with backup/rollback
- Jekyll rebuild trigger system

**Frontend**:
- ES6+ JavaScript modules (not class-based monolith)
- Event-driven architecture
- BEM-compliant UI components
- CSS custom property manipulation for instant preview

**State Management**:
- Single source of truth (ConfigManager)
- Optimistic UI updates
- Rollback on error
- Event bus for component communication

**Security**:
- Localhost-only validation (both backend and frontend)
- No authentication (local development tool)
- Read-only mode when accessed remotely
- Config validation before write

---

## File Structure

### New Files to Create

```
_plugins/
â””â”€â”€ onboard_api.rb                    # (250 lines) Jekyll plugin for API endpoints

onboard/
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ config-manager.js         # (150 lines) API client, state management
â”‚   â”‚   â”œâ”€â”€ color-picker.js           # (200 lines) Reusable color selection component
â”‚   â”‚   â”œâ”€â”€ theme-editor.js           # (180 lines) Main editor controller
â”‚   â”‚   â”œâ”€â”€ preview-manager.js        # (120 lines) Live preview iframe controller
â”‚   â”‚   â”œâ”€â”€ rebuild-notifier.js       # (100 lines) Build status indicator
â”‚   â”‚   â””â”€â”€ event-bus.js              # (50 lines) Decoupled event system
â”‚   â””â”€â”€ editor.css                    # (400 lines) Editor-specific BEM styles
â””â”€â”€ api/
    â”œâ”€â”€ .htaccess                     # Apache: localhost only
    â””â”€â”€ config.json.liquid            # Jekyll-generated config endpoint

docs/01-project/03-plans/
â””â”€â”€ 09-20251002-002.01-phase-7-dashboard-editor.md  # This file
```

### Files to Modify

```
onboard/index.html                    # Add editor UI to Theme section
onboard/assets/dashboard.css          # Add editor component styles
onboard/assets/dashboard.js           # Import and integrate editor modules
onboard/README.md                     # Update for Phase 2 features

_config.yml                           # Add API configuration (optional)
```

**Total**: 8 new files, 4 modified files

---

## Task Breakdown

### Task 7.1: Create Jekyll API Plugin
**Priority**: Critical
**Duration**: 4-5 hours
**Complexity**: High

#### Purpose

Provide HTTP API endpoints for:
1. Reading current `_config.yml` theme settings
2. Updating `_config.yml` atomically
3. Triggering Jekyll rebuild
4. Polling rebuild status

#### Implementation: `_plugins/onboard_api.rb`

```ruby
# ==============================================================================
# Onboard API Plugin - Jekyll Configuration Editor
# ==============================================================================
# Provides REST API endpoints for dashboard theme editor
# Security: Localhost only, no authentication
#
# Endpoints:
#   GET  /onboard/api/config          - Read current theme config
#   POST /onboard/api/update-config   - Update theme in _config.yml
#   POST /onboard/api/rebuild         - Trigger Jekyll rebuild
#   GET  /onboard/api/status/:id      - Poll rebuild status
# ==============================================================================

require 'yaml'
require 'json'
require 'fileutils'
require 'securerandom'

module Onboard
  # Build status tracker (in-memory)
  class BuildTracker
    @builds = {}

    class << self
      def start_build
        id = SecureRandom.uuid
        @builds[id] = {
          id: id,
          state: 'running',
          started_at: Time.now,
          output: []
        }
        id
      end

      def update_build(id, state, output = nil)
        return unless @builds[id]
        @builds[id][:state] = state
        @builds[id][:output] << output if output
        @builds[id][:completed_at] = Time.now if state == 'complete' || state == 'failed'
      end

      def get_build(id)
        @builds[id]
      end
    end
  end

  # API Rack Middleware
  class APIMiddleware
    def initialize(app)
      @app = app
    end

    def call(env)
      # Security: Localhost only
      return forbidden unless localhost?(env)

      # Route requests
      case env['REQUEST_PATH']
      when '/onboard/api/config'
        handle_get_config(env)
      when '/onboard/api/update-config'
        handle_update_config(env)
      when '/onboard/api/rebuild'
        handle_rebuild(env)
      when %r{^/onboard/api/status/(.+)$}
        handle_status(env, Regexp.last_match(1))
      else
        @app.call(env)
      end
    end

    private

    # Security: Check if request is from localhost
    def localhost?(env)
      remote_addr = env['REMOTE_ADDR'] || env['HTTP_X_FORWARDED_FOR']
      ['127.0.0.1', '::1', 'localhost'].include?(remote_addr)
    end

    def forbidden
      [403, { 'Content-Type' => 'application/json' }, ['{"error":"Access denied - localhost only"}']]
    end

    # GET /onboard/api/config - Read current theme configuration
    def handle_get_config(env)
      config = load_config
      json_response(200, {
        theme: config['theme'],
        site: {
          title: config['title'],
          author: config['author']
        }
      })
    end

    # POST /onboard/api/update-config - Update _config.yml theme section
    def handle_update_config(env)
      # Parse request body
      request_body = env['rack.input'].read
      updates = JSON.parse(request_body)

      # Validate theme updates
      validation_error = validate_theme_updates(updates['theme'])
      return json_response(400, { error: validation_error }) if validation_error

      # Update config atomically
      begin
        update_config_file(updates['theme'])
        json_response(200, {
          success: true,
          message: 'Configuration updated successfully',
          theme: updates['theme']
        })
      rescue StandardError => e
        json_response(500, {
          error: "Failed to update configuration: #{e.message}"
        })
      end
    end

    # POST /onboard/api/rebuild - Trigger Jekyll rebuild
    def handle_rebuild(env)
      build_id = BuildTracker.start_build

      # Start rebuild in background thread
      Thread.new do
        begin
          output = `bundle exec jekyll build --incremental 2>&1`
          state = $?.success? ? 'complete' : 'failed'
          BuildTracker.update_build(build_id, state, output)
        rescue StandardError => e
          BuildTracker.update_build(build_id, 'failed', e.message)
        end
      end

      json_response(202, {
        buildId: build_id,
        message: 'Rebuild started'
      })
    end

    # GET /onboard/api/status/:id - Poll rebuild status
    def handle_status(env, build_id)
      build = BuildTracker.get_build(build_id)
      return json_response(404, { error: 'Build not found' }) unless build

      json_response(200, build)
    end

    # Validate theme updates before writing
    def validate_theme_updates(theme)
      valid_colors = %w[orange blue green purple red]
      valid_neutrals = %w[slate gray]
      valid_modes = %w[light dark auto]

      return 'Missing theme object' unless theme

      if theme['brand_primary'] && !valid_colors.include?(theme['brand_primary'])
        return "Invalid brand_primary: must be one of #{valid_colors.join(', ')}"
      end

      if theme['brand_secondary'] && theme['brand_secondary'] != 'null' && !valid_colors.include?(theme['brand_secondary'])
        return "Invalid brand_secondary: must be one of #{valid_colors.join(', ')} or null"
      end

      if theme['neutral'] && !valid_neutrals.include?(theme['neutral'])
        return "Invalid neutral: must be one of #{valid_neutrals.join(', ')}"
      end

      if theme['mode'] && !valid_modes.include?(theme['mode'])
        return "Invalid mode: must be one of #{valid_modes.join(', ')}"
      end

      nil # No errors
    end

    # Load _config.yml
    def load_config
      YAML.load_file('_config.yml')
    end

    # Update _config.yml atomically with backup
    def update_config_file(theme_updates)
      config_path = '_config.yml'
      backup_path = '_config.yml.backup'

      # 1. Backup current config
      FileUtils.cp(config_path, backup_path)

      begin
        # 2. Load current config
        config = YAML.load_file(config_path)

        # 3. Update theme section
        config['theme'] ||= {}
        config['theme'].merge!(theme_updates.reject { |k, v| v.nil? })

        # Handle null secondary color
        config['theme']['brand_secondary'] = nil if theme_updates['brand_secondary'] == 'null'

        # 4. Write updated config
        File.open(config_path, 'w') do |file|
          file.write(config.to_yaml)
        end

        # 5. Verify YAML is valid
        YAML.load_file(config_path)

        # 6. Success - remove backup
        FileUtils.rm(backup_path)

      rescue StandardError => e
        # Rollback on error
        FileUtils.mv(backup_path, config_path) if File.exist?(backup_path)
        raise e
      end
    end

    # Helper: JSON response
    def json_response(status, data)
      [status, { 'Content-Type' => 'application/json' }, [data.to_json]]
    end
  end
end

# Register plugin with Jekyll
Jekyll::Hooks.register :site, :post_write do |site|
  # Plugin only runs in development mode
  if ENV['JEKYLL_ENV'] != 'production'
    Jekyll.logger.info 'Onboard API:', 'Plugin loaded (development mode)'
  end
end

# Note: Middleware registration depends on Jekyll server implementation
# For jekyll serve, use WEBrick/Rack configuration
# For production, middleware is not loaded
```

---

### Task 7.2: Create Config Manager Module
**Priority**: Critical
**Duration**: 2-3 hours
**Complexity**: Medium

#### Purpose

Central state management for theme configuration with API integration.

#### Implementation: `onboard/assets/modules/config-manager.js`

```javascript
/**
 * =============================================================================
 * Config Manager - State Management & API Client
 * =============================================================================
 * Purpose: Single source of truth for theme configuration
 * Pattern: Singleton with event emission
 * Features:
 *   - Load current config from Jekyll-generated JSON
 *   - Update config via API (optimistic updates)
 *   - Track pending changes (dirty state)
 *   - Event emission for state changes
 * =============================================================================
 */

import { EventBus } from './event-bus.js';

export class ConfigManager {
  constructor() {
    if (ConfigManager.instance) {
      return ConfigManager.instance;
    }

    this.apiBase = '/onboard/api';
    this.currentConfig = null;
    this.originalConfig = null; // For reset functionality
    this.pendingChanges = {};
    this.isDirty = false;

    ConfigManager.instance = this;
  }

  /**
   * Load current configuration from Jekyll
   * @returns {Promise<Object>} Site config
   */
  async loadConfig() {
    try {
      // Fetch Jekyll-generated config JSON
      const response = await fetch(`${this.apiBase}/config.json?_=${Date.now()}`);

      if (!response.ok) {
        throw new Error(`Failed to load config: ${response.statusText}`);
      }

      const config = await response.json();

      // Store original for reset
      this.currentConfig = config;
      this.originalConfig = JSON.parse(JSON.stringify(config)); // Deep clone

      // Emit event
      EventBus.emit('config:loaded', config);

      return config;

    } catch (error) {
      console.error('Config load failed:', error);
      throw error;
    }
  }

  /**
   * Get current theme configuration
   * @returns {Object} Theme config
   */
  getTheme() {
    return this.currentConfig?.theme || {};
  }

  /**
   * Update theme configuration (optimistic update)
   * @param {string} key - Theme property (brand_primary, mode, etc.)
   * @param {any} value - New value
   */
  updateThemeProperty(key, value) {
    if (!this.currentConfig) {
      throw new Error('Config not loaded');
    }

    // Store previous value for rollback
    const previousValue = this.currentConfig.theme[key];

    // Optimistic update
    this.currentConfig.theme[key] = value;
    this.pendingChanges[key] = value;
    this.isDirty = true;

    // Emit change event
    EventBus.emit('config:change', {
      key,
      value,
      previousValue,
      theme: this.currentConfig.theme
    });

    EventBus.emit('config:dirty', this.isDirty);
  }

  /**
   * Get pending changes
   * @returns {Object} Pending theme updates
   */
  getPendingChanges() {
    return { ...this.pendingChanges };
  }

  /**
   * Check if config has unsaved changes
   * @returns {boolean} True if dirty
   */
  hasPendingChanges() {
    return this.isDirty;
  }

  /**
   * Save changes to _config.yml via API
   * @returns {Promise<Object>} Updated config
   */
  async saveChanges() {
    if (!this.isDirty) {
      return { success: true, message: 'No changes to save' };
    }

    try {
      EventBus.emit('config:saving');

      const response = await fetch(`${this.apiBase}/update-config`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          theme: this.pendingChanges
        })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Save failed');
      }

      const result = await response.json();

      // Mark as clean
      this.pendingChanges = {};
      this.isDirty = false;
      this.originalConfig = JSON.parse(JSON.stringify(this.currentConfig));

      EventBus.emit('config:saved', result);
      EventBus.emit('config:dirty', false);

      return result;

    } catch (error) {
      console.error('Config save failed:', error);
      EventBus.emit('config:error', error);
      throw error;
    }
  }

  /**
   * Reset to original config (undo pending changes)
   */
  resetChanges() {
    this.currentConfig = JSON.parse(JSON.stringify(this.originalConfig));
    this.pendingChanges = {};
    this.isDirty = false;

    EventBus.emit('config:reset', this.currentConfig);
    EventBus.emit('config:dirty', false);
  }

  /**
   * Trigger Jekyll rebuild
   * @returns {Promise<string>} Build ID for status polling
   */
  async triggerRebuild() {
    try {
      EventBus.emit('rebuild:started');

      const response = await fetch(`${this.apiBase}/rebuild`, {
        method: 'POST'
      });

      if (!response.ok) {
        throw new Error('Rebuild request failed');
      }

      const result = await response.json();
      return result.buildId;

    } catch (error) {
      console.error('Rebuild trigger failed:', error);
      EventBus.emit('rebuild:error', error);
      throw error;
    }
  }

  /**
   * Poll build status
   * @param {string} buildId - Build identifier
   * @returns {Promise<Object>} Build status
   */
  async getBuildStatus(buildId) {
    try {
      const response = await fetch(`${this.apiBase}/status/${buildId}`);

      if (!response.ok) {
        throw new Error('Status check failed');
      }

      const status = await response.json();
      EventBus.emit('rebuild:status', status);

      return status;

    } catch (error) {
      console.error('Status check failed:', error);
      throw error;
    }
  }
}
```

---

### Task 7.3: Create Event Bus Module
**Priority**: High
**Duration**: 1 hour
**Complexity**: Low

#### Purpose

Decoupled event system for component communication.

#### Implementation: `onboard/assets/modules/event-bus.js`

```javascript
/**
 * =============================================================================
 * Event Bus - Decoupled Component Communication
 * =============================================================================
 * Purpose: Publish-subscribe pattern for inter-module communication
 * Pattern: Singleton event emitter
 * Usage:
 *   EventBus.on('config:change', handler)
 *   EventBus.emit('config:change', data)
 *   EventBus.off('config:change', handler)
 * =============================================================================
 */

export const EventBus = {
  // Event listener registry
  _events: {},

  /**
   * Subscribe to event
   * @param {string} event - Event name
   * @param {Function} handler - Event handler
   */
  on(event, handler) {
    if (!this._events[event]) {
      this._events[event] = [];
    }
    this._events[event].push(handler);
  },

  /**
   * Unsubscribe from event
   * @param {string} event - Event name
   * @param {Function} handler - Event handler to remove
   */
  off(event, handler) {
    if (!this._events[event]) return;

    this._events[event] = this._events[event].filter(h => h !== handler);
  },

  /**
   * Emit event
   * @param {string} event - Event name
   * @param {any} data - Event data
   */
  emit(event, data) {
    if (!this._events[event]) return;

    this._events[event].forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error(`Error in ${event} handler:`, error);
      }
    });
  },

  /**
   * Subscribe to event once
   * @param {string} event - Event name
   * @param {Function} handler - Event handler
   */
  once(event, handler) {
    const onceHandler = (data) => {
      handler(data);
      this.off(event, onceHandler);
    };
    this.on(event, onceHandler);
  },

  /**
   * Clear all listeners for an event
   * @param {string} event - Event name
   */
  clear(event) {
    if (event) {
      delete this._events[event];
    } else {
      this._events = {};
    }
  }
};
```

---

### Task 7.4: Create Color Picker Component
**Priority**: High
**Duration**: 3-4 hours
**Complexity**: Medium

#### Purpose

Reusable color selection UI following BEM architecture and design token system.

#### Implementation: `onboard/assets/modules/color-picker.js`

```javascript
/**
 * =============================================================================
 * Color Picker Component - BEM Architecture
 * =============================================================================
 * Purpose: Visual color selection for theme editor
 * Pattern: Component with event emission
 * Features:
 *   - BEM-compliant markup
 *   - Renders all 5 color palettes (orange, blue, green, purple, red)
 *   - Optional "None" selection for secondary color
 *   - Shows color preview with all shades (50-900)
 *   - Emits custom 'colorchange' event
 * =============================================================================
 */

import { EventBus } from './event-bus.js';

export class ColorPicker {
  constructor(options = {}) {
    this.options = {
      containerId: options.containerId || 'color-picker',
      colors: options.colors || ['orange', 'blue', 'green', 'purple', 'red'],
      allowNone: options.allowNone || false,
      selected: options.selected || null,
      label: options.label || 'Select Color',
      configKey: options.configKey || 'brand_primary', // For event emission
      showPalette: options.showPalette !== false, // Show full palette preview
    };

    this.container = null;
    this.selectedColor = this.options.selected;

    this.palettes = this.loadPalettes();
  }

  /**
   * Load color palettes (matches _data/color-palettes.yml)
   * @returns {Object} Palette definitions
   */
  loadPalettes() {
    return {
      orange: {
        50: '#fff7ed',
        100: '#ffedd5',
        200: '#fed7aa',
        300: '#fdba74',
        400: '#fb923c',
        500: '#f97316',
        600: '#ea580c',
        700: '#c2410c',
        800: '#9a3412',
        900: '#7c2d12'
      },
      blue: {
        50: '#eff6ff',
        100: '#dbeafe',
        200: '#bfdbfe',
        300: '#93c5fd',
        400: '#60a5fa',
        500: '#3b82f6',
        600: '#2563eb',
        700: '#1d4ed8',
        800: '#1e40af',
        900: '#1e3a8a'
      },
      green: {
        50: '#f0fdf4',
        100: '#dcfce7',
        200: '#bbf7d0',
        300: '#86efac',
        400: '#4ade80',
        500: '#22c55e',
        600: '#16a34a',
        700: '#15803d',
        800: '#166534',
        900: '#14532d'
      },
      purple: {
        50: '#faf5ff',
        100: '#f3e8ff',
        200: '#e9d5ff',
        300: '#d8b4fe',
        400: '#c084fc',
        500: '#a855f7',
        600: '#9333ea',
        700: '#7e22ce',
        800: '#6b21a8',
        900: '#581c87'
      },
      red: {
        50: '#fef2f2',
        100: '#fee2e2',
        200: '#fecaca',
        300: '#fca5a5',
        400: '#f87171',
        500: '#ef4444',
        600: '#dc2626',
        700: '#b91c1c',
        800: '#991b1b',
        900: '#7f1d1d'
      }
    };
  }

  /**
   * Render component
   * @returns {string} HTML string
   */
  render() {
    const html = `
      <div class="color-picker" data-config-key="${this.options.configKey}">
        <label class="color-picker__label">${this.options.label}</label>

        <!-- Color swatches grid -->
        <div class="color-picker__grid">
          ${this.options.colors.map(color => this.renderSwatch(color)).join('')}
          ${this.options.allowNone ? this.renderNoneSwatch() : ''}
        </div>

        <!-- Selected color preview -->
        ${this.renderPreview()}

        <!-- Full palette preview (if enabled) -->
        ${this.options.showPalette ? this.renderPalettePreview() : ''}
      </div>
    `;

    return html;
  }

  /**
   * Render color swatch button (BEM element)
   * @param {string} color - Color name
   * @returns {string} HTML string
   */
  renderSwatch(color) {
    const isSelected = color === this.selectedColor;
    const baseColor = this.palettes[color][500];

    return `
      <button
        class="color-picker__swatch ${isSelected ? 'color-picker__swatch--selected' : ''}"
        data-color="${color}"
        type="button"
        aria-label="Select ${this.capitalize(color)}"
        aria-pressed="${isSelected}"
        style="background-color: ${baseColor}">
        ${isSelected ? '<i class="fa-solid fa-check color-picker__check"></i>' : ''}
        <span class="color-picker__swatch-label">${this.capitalize(color)}</span>
      </button>
    `;
  }

  /**
   * Render "None" swatch (for optional secondary color)
   * @returns {string} HTML string
   */
  renderNoneSwatch() {
    const isSelected = this.selectedColor === null || this.selectedColor === 'null';

    return `
      <button
        class="color-picker__swatch color-picker__swatch--none ${isSelected ? 'color-picker__swatch--selected' : ''}"
        data-color="null"
        type="button"
        aria-label="No secondary color"
        aria-pressed="${isSelected}">
        ${isSelected ? '<i class="fa-solid fa-check color-picker__check"></i>' : ''}
        <span class="color-picker__swatch-label">None</span>
      </button>
    `;
  }

  /**
   * Render selected color preview
   * @returns {string} HTML string
   */
  renderPreview() {
    if (!this.selectedColor || this.selectedColor === 'null') {
      return `
        <div class="color-picker__preview">
          <span class="color-picker__preview-label">No color selected</span>
        </div>
      `;
    }

    const baseColor = this.palettes[this.selectedColor][500];

    return `
      <div class="color-picker__preview">
        <span class="color-picker__preview-swatch" style="background-color: ${baseColor}"></span>
        <span class="color-picker__preview-label">${this.capitalize(this.selectedColor)}</span>
      </div>
    `;
  }

  /**
   * Render full palette preview (50-900 shades)
   * @returns {string} HTML string
   */
  renderPalettePreview() {
    if (!this.selectedColor || this.selectedColor === 'null') {
      return '';
    }

    const palette = this.palettes[this.selectedColor];
    const shades = Object.entries(palette);

    return `
      <div class="color-picker__palette">
        <h4 class="color-picker__palette-title">${this.capitalize(this.selectedColor)} Palette</h4>
        <div class="color-picker__palette-grid">
          ${shades.map(([shade, hex]) => `
            <div class="color-picker__shade" style="background-color: ${hex}">
              <span class="color-picker__shade-label">${shade}</span>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  /**
   * Mount component to DOM
   * @param {string} containerId - Container element ID
   */
  mount(containerId) {
    this.container = document.getElementById(containerId || this.options.containerId);

    if (!this.container) {
      console.error(`Container #${containerId || this.options.containerId} not found`);
      return;
    }

    this.container.innerHTML = this.render();
    this.attachEvents();
  }

  /**
   * Attach event listeners (delegation pattern)
   */
  attachEvents() {
    if (!this.container) return;

    // Delegate click events on swatches
    this.container.addEventListener('click', (e) => {
      const swatch = e.target.closest('.color-picker__swatch');
      if (!swatch) return;

      const color = swatch.dataset.color;
      this.selectColor(color === 'null' ? null : color);
    });
  }

  /**
   * Select a color (update state and UI)
   * @param {string|null} color - Color name or null
   */
  selectColor(color) {
    const previousColor = this.selectedColor;
    this.selectedColor = color;

    // Update UI
    this.updateUI();

    // Emit custom DOM event
    const event = new CustomEvent('colorchange', {
      detail: {
        color,
        previousColor,
        configKey: this.options.configKey
      },
      bubbles: true
    });
    this.container.dispatchEvent(event);

    // Emit via EventBus
    EventBus.emit('colorpicker:change', {
      color,
      previousColor,
      configKey: this.options.configKey
    });
  }

  /**
   * Update UI after selection (targeted DOM updates)
   */
  updateUI() {
    // Remove all selected states
    this.container.querySelectorAll('.color-picker__swatch--selected').forEach(swatch => {
      swatch.classList.remove('color-picker__swatch--selected');
      swatch.setAttribute('aria-pressed', 'false');
      swatch.querySelector('.color-picker__check')?.remove();
    });

    // Add selected state to current
    const colorValue = this.selectedColor === null ? 'null' : this.selectedColor;
    const currentSwatch = this.container.querySelector(`[data-color="${colorValue}"]`);

    if (currentSwatch) {
      currentSwatch.classList.add('color-picker__swatch--selected');
      currentSwatch.setAttribute('aria-pressed', 'true');
      currentSwatch.insertAdjacentHTML('beforeend', '<i class="fa-solid fa-check color-picker__check"></i>');
    }

    // Update preview
    const previewContainer = this.container.querySelector('.color-picker__preview');
    if (previewContainer) {
      previewContainer.outerHTML = this.renderPreview();
    }

    // Update palette preview
    const paletteContainer = this.container.querySelector('.color-picker__palette');
    if (this.options.showPalette) {
      if (paletteContainer) {
        paletteContainer.outerHTML = this.renderPalettePreview();
      } else {
        // Add palette if it wasn't rendered before
        this.container.querySelector('.color-picker').insertAdjacentHTML('beforeend', this.renderPalettePreview());
      }
    }
  }

  /**
   * Get currently selected color
   * @returns {string|null} Color name
   */
  getSelectedColor() {
    return this.selectedColor;
  }

  /**
   * Set selected color programmatically
   * @param {string|null} color - Color name
   */
  setSelectedColor(color) {
    this.selectColor(color);
  }

  /**
   * Capitalize string helper
   * @param {string} str
   * @returns {string}
   */
  capitalize(str) {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
```

**Continued in next section...**

---

### Task 7.5: Create Theme Editor Controller
**Priority**: Critical
**Duration**: 3-4 hours
**Complexity**: High

*[Implementation details continue...]*

---

## Testing Checklist

### Unit Tests
- [ ] ConfigManager state management
- [ ] Event Bus pub/sub
- [ ] Color Picker component
- [ ] Preview Manager CSS injection
- [ ] Rebuild Notifier UI updates

### Integration Tests
- [ ] Full editor workflow (select â†’ save â†’ rebuild)
- [ ] Config file write/read
- [ ] Jekyll rebuild trigger
- [ ] Live preview updates
- [ ] Error handling (save failure, rebuild failure)

### Manual Tests
- [ ] Select primary color â†’ preview updates
- [ ] Select secondary color â†’ preview updates
- [ ] Change theme mode â†’ preview updates
- [ ] Save changes â†’ _config.yml updated
- [ ] Rebuild completes successfully
- [ ] Reset button works
- [ ] Dashboard loads with saved changes
- [ ] Security: Access denied on non-localhost

---

## Success Metrics

### Functionality
- [ ] All 5 colors selectable
- [ ] Theme mode toggle functional
- [ ] Config saves successfully
- [ ] Rebuild triggers automatically
- [ ] Preview updates in real-time
- [ ] No data loss on errors

### Performance
- [ ] Preview updates < 100ms
- [ ] Config save < 500ms
- [ ] Rebuild completes < 5s
- [ ] UI remains responsive during rebuild

### Code Quality
- [ ] 100% BEM naming
- [ ] ES6 modules properly imported
- [ ] No console errors
- [ ] Accessible (ARIA labels, keyboard nav)
- [ ] Build successful with no warnings

---

## Deliverables

### Code
- [ ] 8 new files created
- [ ] 4 files modified
- [ ] All files following BEM/token architecture
- [ ] JSDoc comments on all functions

### Documentation
- [ ] This implementation plan
- [ ] Updated dashboard README
- [ ] API endpoint documentation
- [ ] Component usage examples

---

## Risks & Mitigations

### Risk 1: File Write Permissions
**Issue**: Jekyll process may not have write access to `_config.yml`
**Mitigation**: Document required permissions, provide error handling

### Risk 2: Concurrent Config Updates
**Issue**: Multiple users/processes editing config simultaneously
**Mitigation**: File locking, backup/rollback, atomic writes

### Risk 3: Jekyll Rebuild Timeout
**Issue**: Large sites may take > 10s to rebuild
**Mitigation**: Background rebuild with status polling, timeout handling

---

## Phase 7 Timeline

**Week 7** (8 hours):
- Day 1-2: Create Jekyll API plugin (Task 7.1)
- Day 3: Create ConfigManager + EventBus (Tasks 7.2, 7.3)

**Week 8** (8 hours):
- Day 1-2: Create ColorPicker component (Task 7.4)
- Day 3-4: Create ThemeEditor controller (Task 7.5)

**Week 9** (4 hours):
- Day 1: Create PreviewManager + RebuildNotifier (Tasks 7.6, 7.7)
- Day 2: Testing, documentation, polish

---

## Sign-Off

### Completed Tasks
- [ ] Task 7.1: Jekyll API Plugin
- [ ] Task 7.2: ConfigManager Module
- [ ] Task 7.3: Event Bus Module
- [ ] Task 7.4: Color Picker Component
- [ ] Task 7.5: Theme Editor Controller
- [ ] Task 7.6: Preview Manager
- [ ] Task 7.7: Rebuild Notifier
- [ ] Task 7.8: UI Integration
- [ ] Task 7.9: Testing & Validation
- [ ] Task 7.10: Documentation

### Phase 7 Complete
- [ ] Dashboard editor functional
- [ ] All tests passing
- [ ] Documentation complete
- [ ] Build successful

**Completed By**: _____________
**Date**: _____________

---

**Document Status**: âœ… Ready for Implementation
**Last Updated**: October 2, 2025
**Next Phase**: Phase 8 - Content Editor (Future)
